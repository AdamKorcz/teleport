---
authors: Alexander Klizhentas (sasha@gravitational.com)
state: discussion
---

# RFD 8 - API and Client Libraries

## What

Document and publish API OpenAPI spec and documentation.
Unify Golang Client experience.

## Why

There are several problems with Go client libraries:

* Go library example pulls entire teleport dependency including `lib/auth` and `lib/services`.
* There is no separate client library with guarantees of compatibility  with specific version of Teleport.
See examples [here](https://github.com/kubernetes/client-go#compatibility-matrix).
*  It's impossible to generate library in any other language other than Go due to unclear API surface.
*  Some client logic is residing in [plugins](https://github.com/gravitational/teleport-plugins/blob/master/access/access.go),
while other is in `lib/auth`.

* Code in `lib/auth` uses some concepts  unfamiliar to Go users:

```go
// connectClient establishes a gRPC connection to an auth server.
func connectClient() (*auth.Client, error) {
    tlsConfig, err := LoadTLSConfig("certs/api-admin.crt", "certs/api-admin.key", "certs/api-admin.cas")
    if err != nil {
        return nil, fmt.Errorf("Failed to setup TLS config: %v", err)
    }

    // must part addr list panics and is not necessary
    authServerAddr := utils.MustParseAddrList("127.0.0.1:3025")
    clientConfig := auth.ClientConfig{Addrs: authServerAddr, TLS: tlsConfig}

    // TLS client is the only client
    return auth.NewTLSClient(clientConfig)
```

## Details

### Approach

Keep Teleport's API layer unified, avoid having internal API vs external API layer.
The access to the API surface is limited by role based access control.

Avoid large refactors, instead use Go's type aliases to move things around while keeping things backwards compatible.

```
// Preserve full backwards compatibility while keeping
type services.Role = types.Role
type auth.Service = proto.Service
```

Use Swagger and OpenAPI to document our SDKs.

#### Move protobuf types and services

Point protobuf generators to generate types to another folder and use a system of submodules:

```
$ ls github.com/gravitational/teleport/api
# root folder with API specs and is a submodule
api/
  # open API spec used for swagger, see for example K8s Swagger spec
  # https://github.com/kubernetes/kubernetes/tree/master/api/openapi-spec
  openapi/
    spec.json
    # move generate services types here, while keeping the original proto files
    # in place in lib/services/services.proto
  types/
    types.pb.go
    wrappers.pb.go
  # generate auth service lib/auth/proto here
  client/
    authservice.pb.go
    ```

#### Move client implementation to `api/client`

Move relevant lib/client.*Client code to `api/client`.
Track dependecies, make sure that new `api/client` module has no dependencies
on the outside modules anywhere in `lib`.

**Track depenencies**

Track dependencies to be limited to:
  * `gravitational/roundrip`,  `gravitational/trace`
  * grpc google package and its dependencies
  * protobuf generated code
  * Keep some auth service specific code using `utils.Addr` and other specific code
  *out of the `api/client` and in 


**Go native user experience**

Achieve the user experience in Client:

```go
import (
   "github.com/gravitational/teleport/api/client"
)

func main() {
   // TLS client is the only TLS client supported in teleport
   client, err := client.New(client.Config{
     Addrs: []string{"localhost:3025"},
     // ContextDialer is optional context dialer
     ContextDialer: net.DialContext,
     // direct TLS credentials config
     Credentials: client.TLSCreds(tls.Config)
   })
   ...
   defer client.Close()

   ping, err := client.Ping()
   ...
   fmt.Printf("Ping: %v\n", ping.Version)
}
```

```
$ go mod init
$ go run main.go
```

**Credential providers**

Support multiple credential providers with chaining

* client.TLSCreds(*tls.Config) loads creds from TLS config
* client.PathCreds("path") loads mounted creds from path, detects reloads
and updates the grpc transport

Support convenince method that supports and understands `~/.tsh/profile`,
so users can try testing using credentials they got from `tsh login`

```go
// for testing, use client spec that loads dialer, and credentials from profile
cfg, err := client.LoadTSHConfig()
// cfg.ContextDialer sets up dialer using tunnel dialer in tctl
// TLS creds are loaded from key store, similar how tctl does it in 5.0

client, err := client.New(cfg)
```

```bash
$ tsh login
# try client
$ go run main.go
```

**Auto version checks**

Client should verify that it's implementation is compatible with
teleport's server version by calling `Ping` anc checking the version
similar to tsh logic.

## Move Access requests code into client

Move `access` workflows code into `client` subpackage:

https://github.com/gravitational/teleport-plugins/tree/master/access

Instead of a separate client becomes a subpackage using the only client:

```go
import (
   "github.com/gravitational/teleport/api/client"
   "github.com/gravitational/teleport/api/client/access"
)

func main() {
   client, err := client.New(...)
   watcher, err := access.NewWatcher(ctx, client, access.Watch{State: ...})
   ...
   defer watcher.Close()

```

## Improve API documentation user experience

Integrate Swagger API generated code into `mkdocs` using mkdocs plugin.

## Add Python Client

To prove that new protobuf structure works, generate `python` version of the
golang client:


```bash
ls github.com/gravitational/teleport
api/
python/

$ pip install teleport-client
```

```python
import teleport

client = teleport.client(addr=...)
client.tokens()
```

Update docs to include samples in two languages, Python and Go.
